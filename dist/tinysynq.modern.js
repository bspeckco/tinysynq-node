import{Logger as e}from"tslog";import n from"better-sqlite3";import{nanoid as t}from"nanoid";function a(){return a=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},a.apply(this,arguments)}var r,s;!function(e){e.INSERT="INSERT",e.UPDATE="UPDATE",e.DELETE="DELETE"}(r||(r={})),function(e){e[e.Silly=0]="Silly",e[e.Trace=1]="Trace",e[e.Debug=2]="Debug",e[e.Info=3]="Info",e[e.Warn=4]="Warn",e[e.Error=5]="Error",e[e.Fatal=6]="Fatal"}(s||(s={}));class i{constructor({local:e,remote:n,localId:t,localTime:a,remoteTime:r}){this.local=void 0,this.isGreater=!1,this.isLess=!1,this.isWrongOrder=!1,this.remote={},this.localId=void 0,this.localTime=void 0,this.remoteTime=void 0,this.local=e,this.remote="string"==typeof n?JSON.parse(n):n,this.localId=t,this.localTime=a,this.remoteTime=r}setRemote({remote:e}){this.remote=e}isConflicted(e){const n=(null==e?void 0:e.remote)||this.remote;return Object.keys(a({},this.local,n)).forEach(e=>{const t=this.local[e]||0,a=n[e]||0;this.isGreater=this.isGreater||t>a,this.isLess=this.isLess||t<a}),this.isGreater&&this.isLess}isOutDated(){const{remoteTime:e,localTime:n=new Date("1970-01-01").toISOString()}=this;if(!e||!n)throw new Error("Missing modified time");return n>=e}isOutOfOrder(){const{remote:e,local:n,localId:t}=this;if(!e||!n)throw new Error("Remote vector clock not set");const r=Object.keys(a({},this.local,e)).filter(e=>e!==t);for(let t=0;t<r.length;t++){var s,i;const a=r[t],o=Math.abs((null!=(s=n[a])?s:0)-(null!=(i=e[a])?i:0));this.isWrongOrder=o>1}return this.isWrongOrder}merge(){const e={},n=new Set(Object.keys(this.local).concat(Object.keys(this.remote)));for(const t of n)e[t]=Math.max(this.local[t]||0,this.remote[t]||0);return void 0===e[this.localId]&&(e[this.localId]=0),e}}const o=["id"],l=new e({name:"tinysync-web-init",minLevel:s.Info}),E="STRFTIME('%Y-%m-%dT%H:%M:%f','NOW')";class c{constructor(t){var r,i;if(this._db=void 0,this._dbPath=void 0,this._deviceId=void 0,this._synqPrefix=void 0,this._synqTables=void 0,this._synqBatchSize=20,this._wal=!0,this.log=void 0,this.utils={strtimeAsISO8601:E,nowAsISO8601:E,utcNowAsISO8601:()=>new Date((new Date).toUTCString()).toISOString()},!t.filePath&&!t.sqlite3)throw new Error("No DB filePath or connection provided");const o={};t.tables.forEach(e=>{o[e.name]=e}),this._dbPath=t.filePath||"",this._db=t.sqlite3||void 0,this._synqPrefix=null==(r=t.prefix)?void 0:r.trim().replace(/[^a-z0-9]+$/i,""),this._synqTables=o,this._synqBatchSize=t.batchSize||this._synqBatchSize,this._wal=null!=(i=t.wal)&&i,this.log=new e(a({name:"tinysync-node",minLevel:s.Debug,type:"json",maskValuesOfKeys:["password","encryption_key"],hideLogPositionForProduction:!0},t.logOptions||{})),this.db||(this._db=new n(this.dbPath),this.db.pragma("journal_mode = WAL"))}get db(){return this._db}get dbPath(){return this._dbPath}get deviceId(){return this._deviceId}get synqDbId(){return this._deviceId}get synqPrefix(){return this._synqPrefix}get synqTables(){return this._synqTables}get synqBatchSize(){return this._synqBatchSize}get wal(){return this._wal}getNewId(){return t(16)}getTableIdColumn(e){var n;const{table_name:t}=e;return null==(n=this.synqTables[t])?void 0:n.id}setDeviceId(){var e,n;let a;try{a=this.runQuery({sql:`SELECT meta_value FROM ${this.synqPrefix}_meta WHERE meta_name = 'device_id'`})[0]}catch(e){this.log.warn("Couldn't retrieve device ID")}if(l.warn("@device_id",a),null==(e=a)||!e.meta_value){const e=this.runQuery({sql:`INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value) VALUES (?,?) RETURNING *`,values:["device_id",t(16)]});l.warn("@created record for device_id:",e),a=e[0]}this._deviceId=null==(n=a)?void 0:n.meta_value}run(e){const{sql:n,values:t}=e,a=Math.ceil(1e6*Math.random());this.log.debug("@run",a,n,t,"/");try{const e=this.db.prepare(n).run(t||[]);return this.log.debug({quid:a,result:e}),e}catch(e){return this.log.error(a,e),e}}runMany(e){const{sql:n,values:t}=e,a=Math.ceil(1e6*Math.random());this.log.debug("@runMany",a,n,t,"/");try{const e=this.db.prepare(n);for(const n of t)e.run(n);this.log.debug({quid:a,result:"done"})}catch(e){return this.log.error(a,e),e}}runQuery(e){const{sql:n,values:t}=e,a=Math.ceil(1e6*Math.random());this.log.debug("@runQuery",{quid:a,sql:n,values:t});try{const e=this.db.prepare(n).all(t||[]);return this.log.debug({quid:a,result:e}),e}catch(e){return this.log.error(a,e),e}}getDeviceId(){return this._deviceId?this._deviceId:this.runQuery({sql:`\n        SELECT meta_value FROM ${this.synqPrefix}_meta\n        WHERE meta_name = 'device_id'`})[0].meta_value}getLastSync(){var e;const n=this.runQuery({sql:`\n        SELECT meta_value FROM ${this.synqPrefix}_meta\n        WHERE meta_name = 'last_local_sync'`});return this.log.trace("@getLastSync",n[0]),null==(e=n[0])?void 0:e.meta_value}getChanges(e){let n=(null==e?void 0:e.lastLocalSync)||this.getLastSync(),{columns:t=[]}=e||{};this.log.debug("@getChanges",n);let a="";n&&(a="WHERE c.modified > ?");const r=`\n      SELECT ${t.map(e=>e.replace(/[^*._a-z0-9]+/gi,"")).join(",")||"*"}\n      FROM ${this._synqPrefix}_changes c\n      INNER JOIN ${this._synqPrefix}_record_meta trm\n      ON trm.table_name = c.table_name\n      AND trm.row_id = c.row_id\n      ${a}\n      ORDER BY c.modified ASC\n    `;console.log(r);const s=n?[n]:[];return this.log.debug(r,s),this.runQuery({sql:r,values:s})}getChangesSinceLastSync(e){let n=this.getLastSync()||void 0;return this.getChanges(a({},e,{lastLocalSync:n}))}enableDebug(){return this.run({sql:`\n      INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value)\n      VALUES ('debug_on', '1')\n      RETURNING *;`})}disableDebug(){return this.run({sql:`\n      INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value)\n      VALUES ('debug_on', '0')\n      RETURNING *;`})}clearDebugData(){this.run({sql:`DELETE FROM ${this._synqPrefix}_dump`}),this.run({sql:`UPDATE SQLITE_SEQUENCE SET seq = 0 WHERE name = ${this._synqPrefix}_dump`})}enableTriggers(){return this.run({sql:`\n      INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value)\n      VALUES ('triggers_on', '1');`})}disableTriggers(){return this.run({sql:`\n      INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value)\n      VALUES ('triggers_on', '0');`})}beginTransaction(){const e=`SP${Date.now()}`;return this.run({sql:`SAVEPOINT ${e};`}),e}commitTransaction({savepoint:e}){return this.run({sql:`RELEASE SAVEPOINT ${e};`})}rollbackTransaction({savepoint:e}){return this.run({sql:`ROLLBACK TRANSACTION TO SAVEPOINT ${e};`})}getRecord(e){const{table_name:n,row_id:t}=e,a=this.getTableIdColumn({table_name:n}),r=this.runQuery({sql:`SELECT * FROM ${n} WHERE ${a} = ?`,values:[t]});return this.log.debug("@getRecord",r),r[0]}getById(e){const{table_name:n,row_id:t}=e;return this.getRecord({table_name:n,row_id:t})}insertRecordMeta({change:e,vclock:n}){const{table_name:t,row_id:a}=e,r={table_name:t,row_id:a,mod:n[this._deviceId]||0,vclock:JSON.stringify(n)};return this.runQuery({sql:`\n      INSERT INTO ${this._synqPrefix}_record_meta (table_name, row_id, mod, vclock)\n      VALUES (:table_name, :row_id, :mod, :vclock)\n      ON CONFLICT DO UPDATE SET mod = :mod, vclock = :vclock\n      RETURNING *\n      `,values:r})}getRecordMeta(e){const{table_name:n,row_id:t}=e;return this.db.prepare(`\n    SELECT *\n    FROM ${this.synqPrefix}_record_meta\n    WHERE table_name = :table_name\n    AND row_id = :row_id`).get({table_name:n,row_id:t})}getPending(){return this.runQuery({sql:`\n    SELECT *\n    FROM ${this._synqPrefix}_pending\n    ORDER BY id ASC\n    `})}processOutOfOrderChange({change:e}){const n=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n.indexOf(t=s[a])>=0||(r[t]=e[t]);return r}(e,o),t=this.createInsertFromSystemObject({data:n,table_name:`${this._synqPrefix}_pending`});this.log.trace("@processOutOfOrderChange\n",t,e);const r=a({},n);r.vclock=JSON.stringify(n.vclock);const s=this.runQuery({sql:t,values:r});return this.log.trace("@processOutOfOrderChange\n",{res:s}),s}processConflictedChange({record:e,change:n}){if(n.operation===r.INSERT)return!0;const t=this.getRecordMeta(a({},n));return this.log.trace("<<<@ processConflictedChange LLW @>>>",n.id,n.table_name,n.row_id,{record:e,localMeta:t,change:n}),n.modified>t.modified?(this.log.trace("<!> INTEGRATING REMOTE",n.id,n.table_name,n.row_id),!0):(this.log.warn("<!> KEEPING LOCAL",n.id,n.table_name,n.row_id),!1)}preProcessChange({change:e,restore:n}){let t="unknown",a=!1,r=t;const s=this.deviceId,{table_name:o,row_id:l,vclock:E={}}=e,c=this.getRecord({table_name:o,row_id:l}),d=this.getRecordMeta({table_name:o,row_id:l}),_=null!=d&&d.vclock?JSON.parse(d.vclock):{};let T={};const m=new i({local:_,remote:E,localId:s,localTime:null==d?void 0:d.modified,remoteTime:e.modified});let u=!1,h=!1,R=!1;return n||c||"INSERT"===e.operation?!n&&c&&_&&_[s]||(T=e.vclock):(r="update before insert",this.processOutOfOrderChange({change:e})),n?(a=!0,r="restoration",T=m.merge(),{valid:a,reason:r,vclock:T,checks:{stale:R,displaced:u,conflicted:h}}):((u=m.isOutOfOrder())?(r="received out of order",this.processOutOfOrderChange({change:e})):(h=m.isConflicted())?(a=this.processConflictedChange({record:c,change:e}),a?T=m.merge():r="concurrent writes"):(R=m.isOutDated())?r="stale":r===t&&(a=!0,r="",T=m.merge()),this.log.debug({table_name:o,row_id:l,conflicted:h,displaced:u,stale:R}),{valid:a,reason:r,vclock:T,checks:{stale:R,displaced:u,conflicted:h}})}createInsertFromObject({data:e,table_name:n}){const t=Object.keys(e).join(","),a=this._synqTables[n].editable||[],r=Object.keys(e).filter(e=>a.includes(e)).map(e=>`${e} = :${e}`).join(",");if(!r)throw new Error("No changes available");return`\n      INSERT INTO ${n} (${t})\n      VALUES (${Object.keys(e).map(e=>`:${e}`).join(",")})\n      ON CONFLICT DO UPDATE SET ${r}\n      RETURNING *;`}createInsertFromSystemObject({data:e,table_name:n}){this.log.silly("@createInsert...",{data:e});const t=Object.keys(e).join(","),a=Object.keys(e).map(e=>`${e} = :${e}`).join(",");if(!a)throw new Error("No changes availble");return`\n      INSERT INTO ${n} (${t})\n      VALUES (${Object.keys(e).map(e=>`:${e}`).join(",")})\n      ON CONFLICT DO UPDATE SET ${a}\n      RETURNING *;`}updateLastSync({change:e}){this.run({sql:`INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value) VALUES(:name, STRFTIME('%Y-%m-%d %H:%M:%f','NOW'))`,values:{name:"last_local_sync"}}),this.run({sql:`INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value) VALUES(:name, :value)`,values:{name:"last_sync",value:e.id}})}async applyChange({change:e,restore:n,savepoint:t}){try{const t=this.preProcessChange({change:e,restore:n});if(!t.valid)return this.log.warn(t),void this.updateLastSync({change:e});const a=this.synqTables[e.table_name];let r;if(!e.data)throw new Error(`Cannot perform update with empty data:\n${JSON.stringify(e,null,2)}`);try{r=JSON.parse(e.data)}catch(n){throw this.log.debug(e),new Error("Invalid data for insert or update")}if(!a)throw new Error(`Unable to find table ${e.table_name}`);switch(this.log.silly("@applyChange",{change:e,table:a,changeStatus:t}),e.operation){case"INSERT":case"UPDATE":const n=this.createInsertFromObject({data:r,table_name:e.table_name});await this.run({sql:n,values:r});break;case"DELETE":const t=`DELETE FROM ${e.table_name} WHERE ${a.id} = ?`;this.log.warn(">>> DELETE SQL <<<",t,e.row_id),await this.run({sql:t,values:[e.row_id]})}this.updateLastSync({change:e});const s=this.insertRecordMeta({change:e,vclock:t.vclock});this.log.silly({updatedRecordMeta:s})}catch(e){throw await this.rollbackTransaction({savepoint:t}),this.log.error(`Error applying change: ${e}. Rolled back.`),e}}applyChangesToLocalDB({changes:e,restore:n=!1}){this.disableTriggers();for(let t=0;t<e.length;t+=this.synqBatchSize){const a=e.slice(t,t+this.synqBatchSize),r=this.beginTransaction();try{for(const e of a)this.applyChange({change:e,restore:n,savepoint:r});this.commitTransaction({savepoint:r})}catch(e){this.rollbackTransaction({savepoint:r}),this.log.error(`Transaction failed, changes rolled back: ${e}`)}}this.enableTriggers(),this.log.silly(`Applied ${e.length} change(s)`)}tablesReady(){this.enableTriggers()}}const d=n=>{const{tables:t,preInit:r,postInit:s,logOptions:i,debug:o}=n;if(null==t||!t.length)throw new Error("Syncable table data required");const l=new e(a({name:"tinysync-setup"},i)),E=new c(n),d=({table:e,remove:n=!1})=>{const t=n?"OLD":"NEW",a=`\n    INSERT INTO ${E.synqPrefix}_record_meta (table_name, row_id, mod, vclock)\n    SELECT table_name, row_id, mod, vclock\n    FROM (\n      SELECT\n        1 as peg,\n        '${e.name}' as table_name,\n        ${t}.${e.id} as row_id, \n        IFNULL(json_extract(vclock,'$.${E.deviceId}'), 0) + 1 as mod, \n        json_set(IFNULL(json_extract(vclock, '$'),'{}'), '$.${E.deviceId}', IFNULL(json_extract(vclock,'$.${E.deviceId}'), 0) + 1) as vclock\n      FROM ${E.synqPrefix}_record_meta\n      WHERE table_name = '${e.name}'\n      AND row_id = ${t}.${e.id}\n      UNION\n      SELECT 0 as peg, '${e.name}' as table_name, ${t}.${e.id} as row_id, 1, json_object('${E.deviceId}', 1) as vclock\n    )\n    ORDER BY peg DESC\n    LIMIT 1\n    ON CONFLICT DO UPDATE SET\n      mod = json_extract(excluded.vclock,'$.${E.deviceId}'),\n      vclock = json_extract(excluded.vclock,'$')\n    ;`;return l.silly(a),a},_=({table:e})=>{l.debug("Setting up triggers for",e.name);const n=E.runQuery({sql:`\n      SELECT 'json_object(' || GROUP_CONCAT('''' || name || ''', NEW.' || name, ',') || ')' AS jo\n      FROM pragma_table_info('${e.name}');`})[0];l.silly("@jsonObject",JSON.stringify(n,null,2)),E.run({sql:`DROP TRIGGER IF EXISTS ${E.synqPrefix}_after_insert_${e.name}`}),E.run({sql:`DROP TRIGGER IF EXISTS ${E.synqPrefix}_after_update_${e.name}`}),E.run({sql:`DROP TRIGGER IF EXISTS ${E.synqPrefix}_after_delete_${e.name}`});const t=`\n      CREATE TRIGGER IF NOT EXISTS ${E.synqPrefix}_after_insert_${e.name}\n      AFTER INSERT ON ${e.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${E.synqPrefix}_meta WHERE meta_name = 'triggers_on')='1'\n      BEGIN\n        INSERT INTO ${E.synqPrefix}_changes (table_name, row_id, operation, data)\n        VALUES ('${e.name}', NEW.${e.id}, 'INSERT', ${n.jo});\n\n        ${d({table:e})}\n      END;`;E.run({sql:t}),E.run({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${E.synqPrefix}_after_update_${e.name}\n      AFTER UPDATE ON ${e.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${E.synqPrefix}_meta WHERE meta_name = 'triggers_on')='1'\n      BEGIN\n        INSERT INTO ${E.synqPrefix}_changes (table_name, row_id, operation, data)\n        VALUES ('${e.name}', NEW.${e.id}, 'UPDATE', ${n.jo});\n\n        ${d({table:e})}\n      END;`}),E.run({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${E.synqPrefix}_after_delete_${e.name}\n      AFTER DELETE ON ${e.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${E.synqPrefix}_meta WHERE meta_name = 'triggers_on')='1'\n      BEGIN\n        INSERT INTO ${E.synqPrefix}_changes (table_name, row_id, operation) VALUES ('${e.name}', OLD.${e.id}, 'DELETE');\n        \n        ${d({table:e,remove:!0})}\n      END;`}),E.run({sql:`DROP TRIGGER IF EXISTS ${E.synqPrefix}_dump_after_insert_${e.name}`}),E.run({sql:`DROP TRIGGER IF EXISTS ${E.synqPrefix}_dump_after_update_${e.name}`}),E.run({sql:`DROP TRIGGER IF EXISTS ${E.synqPrefix}_dump_after_delete_${e.name}`}),E.run({sql:`DROP TRIGGER IF EXISTS ${E.synqPrefix}_dump_before_insert_record_meta`}),E.run({sql:`DROP TRIGGER IF EXISTS ${E.synqPrefix}_dump_after_insert_record_meta`}),E.run({sql:`DROP TRIGGER IF EXISTS ${E.synqPrefix}_dump_after_update_record_meta`}),E.run({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${E.synqPrefix}_dump_after_insert_${e.name}\n      AFTER INSERT ON ${e.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${E.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${E.synqPrefix}_dump (table_name, operation, data)\n        VALUES ('${e.name}', 'INSERT', ${n.jo});\n      END;`}),E.run({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${E.synqPrefix}_dump_after_update_${e.name}\n      AFTER UPDATE ON ${e.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${E.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${E.synqPrefix}_dump (table_name, operation, data) VALUES ('${e.name}', 'UPDATE', ${n.jo});\n      END;`});const a=n.jo.replace(/NEW/g,"OLD");E.run({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${E.synqPrefix}_dump_after_delete_${e.name}\n      AFTER DELETE ON ${e.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${E.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${E.synqPrefix}_dump (table_name, operation, data) VALUES ('${e.name}', 'DELETE', ${a});\n      END;`}),E.run({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${E.synqPrefix}_dump_before_insert_record_meta\n      BEFORE INSERT ON ${E.synqPrefix}_record_meta\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${E.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${E.synqPrefix}_dump (table_name, operation, data)\n        VALUES (NEW.table_name, 'BEFORE_INSERT', json_object('table_name', NEW.table_name, 'row_id', NEW.row_id, 'mod', NEW.mod, 'vclock', NEW.vclock));\n      END;`}),E.run({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${E.synqPrefix}_dump_after_insert_record_meta\n      AFTER INSERT ON ${E.synqPrefix}_record_meta\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${E.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${E.synqPrefix}_dump (table_name, operation, data)\n        VALUES ('${e.name}', 'AFTER_INSERT', json_object('table_name', NEW.table_name, 'row_id', NEW.row_id, 'mod', NEW.mod, 'vclock', NEW.vclock));\n      END;`}),E.run({sql:`\n      CREATE TRIGGER IF NOT EXISTS ${E.synqPrefix}_dump_after_update_record_meta\n      AFTER UPDATE ON ${E.synqPrefix}_record_meta\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${E.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${E.synqPrefix}_dump (table_name, operation, data)\n        VALUES ('${e.name}', 'AFTER_UPDATE', json_object('table_name', NEW.table_name, 'row_id', NEW.row_id, 'mod', NEW.mod, 'vclock', NEW.vclock));\n      END;`})};if(E.run({sql:`\n    CREATE TABLE IF NOT EXISTS ${E.synqPrefix}_changes (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      table_name TEXT NOT NULL,\n      row_id TEXT NOT NULL,\n      data BLOB,\n      operation TEXT NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'\n      modified TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%d %H:%M:%f','NOW'))\n    );`}),E.run({sql:`CREATE INDEX IF NOT EXISTS ${E.synqPrefix}_change_modified_idx ON ${E.synqPrefix}_changes(modified)`}),E.run({sql:`\n    CREATE TABLE IF NOT EXISTS ${E.synqPrefix}_pending (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      table_name TEXT NOT NULL,\n      row_id TEXT NOT NULL,\n      data BLOB,\n      operation TEXT NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE',\n      vclock BLOB NOT NULL,\n      modified TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%d %H:%M:%f','NOW'))\n    );`}),E.run({sql:`CREATE INDEX IF NOT EXISTS ${E.synqPrefix}_pending_table_row_idx ON ${E.synqPrefix}_pending(table_name, row_id)`}),E.run({sql:`\n    CREATE TABLE IF NOT EXISTS ${E.synqPrefix}_notice (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      table_name TEXT NOT NULL,\n      row_id TEXT NOT NULL,\n      conflict BLOB,\n      message TEXT NOT NULL,\n      created TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%dT%H:%M:%f','NOW'))\n    );`}),E.run({sql:`\n    CREATE TABLE IF NOT EXISTS ${E.synqPrefix}_record_meta (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      table_name TEXT NOT NULL,\n      row_id TEXT NOT NULL,\n      mod INTEGER,\n      vclock BLOB,\n      modified TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%dT%H:%M:%f','NOW'))\n    );`}),E.run({sql:`CREATE UNIQUE INDEX IF NOT EXISTS ${E.synqPrefix}_record_meta_idx ON ${E.synqPrefix}_record_meta(table_name, row_id)`}),E.run({sql:`\n    CREATE TABLE IF NOT EXISTS ${E.synqPrefix}_meta (\n      meta_name TEXT NOT NULL PRIMARY KEY,\n      meta_value TEXT NOT NULL\n    );\n  `}),E.run({sql:`\n    CREATE TABLE IF NOT EXISTS ${E.synqPrefix}_dump (\n      created TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%d %H:%M:%f','NOW')), \n      table_name TEXT NOT NULL,\n      operation TEXT,\n      data BLOB\n    );\n  `}),E.run({sql:`CREATE INDEX IF NOT EXISTS ${E.synqPrefix}_meta_name_idx ON ${E.synqPrefix}_meta(meta_name)`}),o&&E.enableDebug(),E.setDeviceId(),null!=r&&r.length)for(const e of r)l.debug(`\n@@@ preInit\n${e}\n@@@`),E.run({sql:e});l.debug(`@${E.synqPrefix}_meta`,E.runQuery({sql:`SELECT * FROM pragma_table_info('${E.synqPrefix}_meta')`})),l.debug("@SIMPLE_SELECT",E.runQuery({sql:"SELECT '@@@ that was easy @@@'"}));for(const e of t){const n=E.runQuery({sql:`SELECT * FROM pragma_table_info('${e.name}')`});if(l.debug("@exists?",e.name,n),null==n||!n.length)throw new Error(`${e.name} doesn't exist`);l.debug("Setting up",e.name,e.id),_({table:e}),E.tablesReady()}if(null!=s&&s.length)for(const e of s)l.debug(`@@@\npostInit\n${e}\n@@@`),E.run({sql:e});return E};export{d as default};
//# sourceMappingURL=tinysynq.modern.js.map
