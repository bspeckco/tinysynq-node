{"version":3,"file":"tinysynq.umd.js","sources":["../src/lib/types.ts","../src/lib/vcompare.class.ts","../src/lib/tinysynq.class.ts","../src/lib/constants.ts","../src/lib/index.ts"],"sourcesContent":["import BetterSqlite3 from 'better-sqlite3';\nimport { ISettingsParam, ILogObj } from 'tslog';\n\n/**\n * A {@link https://github.com/WiseLibs/better-sqlite3/blob/master/docs/api.md | BetterSqlite3} instance.\n * \n * @public\n */\nexport type BetterSqlite3Instance = BetterSqlite3.Database\n\n/**\n * Provided to TinySynq constructor.\n * \n * @public\n */\nexport interface SyncableTable {\n  /**\n   * Table name.\n   */\n  name: string;\n  /**\n   * Row identifier; typically the column used as primary key.\n   */\n  id: string;\n  /**\n   * Columns that can be updated by a sync-based change.\n   */\n  editable: string[];\n}\n\n/**\n * Base options for TinySynq constructor.\n * \n * @public\n */\nexport interface TinySynqOptionsBase {\n  /**\n   * A BetterSqlite3 instance.\n   * \n   * @remarks\n   * \n   * If not provided, {@link TinySynqOptionsBase.filePath} must be set.\n   * \n   */\n  sqlite3?: BetterSqlite3Instance;\n  /**\n   * Path to SQLite3 database file.\n   * \n   * @remarks\n   * If not provided, {@link TinySynqOptionsBase.sqlite3} must be set.\n   */\n  filePath?: string;\n  /**\n   * Prefix to use for TinySynq tables (trailing underscores will be removed).\n   */\n  prefix: string;\n  /**\n   * Tables that should be synced between devices.\n   */\n  tables: SyncableTable[];\n  /**\n   * Maximum number of changes to process at once.\n   */\n  batchSize?: number;\n  /**\n   * Enable or disable WAL mode.\n   */\n  wal?: boolean;\n  /**\n   * Array of queries to run before TinySynq's change tracking is configured.\n   * \n   * @remarks\n   * Include create statements for syncable tables here.\n   */\n  preInit?: string[];\n  /**\n   * Array of queries to run after TinySynq's change tracking is configured\n   * \n   * @remarks\n   * You might place any insert queries here.\n   */\n  postInit?: string[];\n  /**\n   * Configure logging options.\n   * \n   * @remarks\n   * TinySynq uses TSLog for logging. All optiions are passed directly to it.\n   * See https://tslog.js.org/#/?id=settings for details\n   */\n  logOptions?: ISettingsParam<ILogObj>;\n  /**\n   * Enable/disable debug mode\n   * \n   * When enabled, all INSERT/UPDATE/DELETE actions on syncable tables are written \n   * to the *_dump table for inspection.\n   */\n  debug?: boolean;\n}\n\n/** \n * Constructor options TinySynq instance.\n * \n * Provide either an existing {@link https://github.com/WiseLibs/better-sqlite3/blob/master/docs/api.md | BetterSqlite3} instance (`sqlite3`) or the `filePath`.\n * \n * @public\n */\nexport interface TinySynqOptionsWithInstance extends TinySynqOptionsBase {\n  /**\n   * A BetterSqlite3 instance.\n   */\n  sqlite3: BetterSqlite3Instance;\n}\n\nexport interface TinySynqOptionsWithFilePath extends TinySynqOptionsBase{\n  /**\n   * Path to SQLite3 database file.\n   */\n  filePath: string;\n}\n\n/** \n * {@inheritdoc TinySynqOptionsBase}\n * \n * @public\n */\nexport type TinySynqOptions = TinySynqOptionsWithInstance | TinySynqOptionsWithFilePath\n\nexport type SQLite3 = any\n\n/**\n * Basic query params for methods that read from/write to DB.\n * \n * @public\n */\nexport type QueryParams = {\n  sql: string;\n  values?: any;\n}\n\n/**\n * Table name and row parameters for retrieving data for a specific record.\n */\nexport interface TableNameRowParams {\n  table_name: string;\n  row_id: string;\n}\n\nexport interface ApplyChangeParams {\n  change: Change,\n  restore?: boolean,\n  savepoint: string\n}\n\nexport interface MetaRowData {\n  meta_name: string;\n  meta_value: string;\n}\n\nexport type VClock = {\n  [deviceId: string]: number;\n}\n\nexport enum TinySynqOperation {\n  'INSERT' = 'INSERT',\n  'UPDATE' = 'UPDATE',\n  'DELETE' = 'DELETE'\n}\n\n/**\n * Object transferred between devices to convey individual record changes.\n * \n * @public\n */\nexport interface Change {\n  /**\n   * Change record ID from central server.\n   */\n  id?: number;\n  /**\n   * Table name of the record that was modified.\n   */\n  table_name: string;\n  /**\n   * Row ID of the record that was modified.\n   */\n  row_id: string;\n  /**\n   * The type of operation that took place.\n   */\n  operation: keyof typeof TinySynqOperation;\n  /**\n   * The serialised object in the post-modified state. \n   */\n  data: string; // JSON string\n  /**\n   * Vector Clock holding all device values for the record, as known by the source device of the change.\n   */\n  vclock: VClock;\n  /**\n   * An ISO8601 formatted date and time that the change was recorded on the source device.\n   */\n  modified: string;\n}\n\nexport enum LogLevel {\n  Silly,\n  Trace,\n  Debug,\n  Info,\n  Warn,\n  Error,\n  Fatal\n};","import { VClock } from \"./types.js\";\n\n\ntype VectorClockParams = {\n  local: VClock;\n  remote: VClock;\n  localId: string;\n  localTime: string;\n  remoteTime: string;\n}\n\ntype RemoteVClockParams = {\n  remote: VClock;\n}\n\nexport class VCompare { // @TODO: rename to VCompare\n\n  private local: VClock;\n  private isGreater = false;\n  private isLess = false;\n  private isWrongOrder = false;\n  private remote: VClock = {};\n  private localId: string;\n  private localTime: string;\n  private remoteTime: string;\n\n\n  constructor({ local, remote, localId, localTime, remoteTime }: VectorClockParams) {\n    this.local = local;\n    this.remote = typeof remote === 'string'\n      ? JSON.parse(remote)\n      : remote;\n    this.localId = localId;\n    this.localTime = localTime;\n    this.remoteTime = remoteTime;\n  }\n\n  setRemote({ remote }: RemoteVClockParams) {\n    this.remote = remote;\n  }\n\n  isConflicted(data?: RemoteVClockParams): boolean {\n    const remote = data?.remote || this.remote;\n    const keys = Object.keys({...this.local, ...remote});\n    keys.forEach(k => {\n      const localCount = this.local[k] || 0;\n      const remoteCount = remote[k] || 0;\n      this.isGreater = this.isGreater || localCount > remoteCount;\n      this.isLess = this.isLess || localCount < remoteCount;\n    });\n    \n    return this.isGreater && this.isLess;\n  }\n\n  isOutDated(): boolean {\n    // Default localTime to any early date so that \n    // remote always wins when local is empty.\n    const { remoteTime, localTime = new Date('1970-01-01').toISOString() } = this;\n    if (!remoteTime || !localTime) throw new Error('Missing modified time');\n    return localTime >= remoteTime;\n  }\n\n  isOutOfOrder(): boolean {\n    const { remote, local, localId } = this;\n    if (!remote || !local) throw new Error('Remote vector clock not set');\n    const keys = Object.keys({...this.local, ...remote}).filter(k => k !== localId);\n    for (let i = 0; i < keys.length; i++) {\n      const k = keys[i];\n      const drift = Math.abs((local[k] ?? 0) - (remote[k] ?? 0));\n      this.isWrongOrder = drift > 1;\n    }\n    return this.isWrongOrder;\n  }\n\n  merge() {\n    const merged: VClock = {};\n    const participants = new Set(Object.keys(this.local).concat(Object.keys(this.remote)));\n    // If the incoming participant vclock is lower, discard\n    for (const p of participants) {\n      const localP = this.local[p] || 0;\n      const remoteP = this.remote[p] || 0;\n      merged[p] = Math.max(localP, remoteP);\n    }\n    if (merged[this.localId] === undefined) {\n      merged[this.localId] = 0;\n    }\n    return merged;\n  }\n}","import DB from 'better-sqlite3'\nimport { ApplyChangeParams, Change, LogLevel, QueryParams, TinySynqOptions, SyncableTable, TableNameRowParams, VClock, TinySynqOperation } from './types.js';\nimport { Logger, ILogObj } from 'tslog';\nimport { nanoid } from 'nanoid';\nimport { VCompare } from './vcompare.class.js';\nimport { SYNQ_INSERT } from './constants.js';\n\nconst log = new Logger({ name: 'tinysync-web-init', minLevel: LogLevel.Info });\nconst strtimeAsISO8601 = `STRFTIME('%Y-%m-%dT%H:%M:%f','NOW')`;\n\ntype PreProcessChangeOptions = {\n  change: Change, restore?: boolean\n}\n\ntype PreProcessChangeResult = { \n  valid: boolean;\n  reason: string;\n  vclock: VClock;\n  checks: Record<string, boolean>\n}\n\n/**\n * Basic utilities, mainly date-oriented.\n */\nexport type Utils = {\n  strtimeAsISO8601: string,\n  nowAsISO8601: string,\n  utcNowAsISO8601: () => string\n}\n\n/**\n * Parameters for retrieving table's ID column.\n * \n * @public\n */\nexport type GetTableIdColumnParams = {\n  table_name: string;\n}\n\n/**\n * The main class for managing SQLite3 synchronisation.\n * \n * @remarks\n * Expects SQLite3 version \\>=3.45.1\n * \n * @public\n */\nexport class TinySynq {\n  private _db: any;\n  private _dbPath: string;\n  private _deviceId: string | undefined;\n  private _synqPrefix?: string;\n  private _synqTables?: Record<string, SyncableTable>;\n  private _synqBatchSize: number = 20;\n  private _wal = true;\n  private log: Logger<ILogObj>;\n\n  /**\n   * Basic Helpers.\n   * \n   * @TODO move to a separate file.\n   * \n   * @public\n   */\n  readonly utils: Utils = {\n    strtimeAsISO8601,\n    nowAsISO8601: strtimeAsISO8601,\n    utcNowAsISO8601: (): string => {\n      return new Date((new Date()).toUTCString()).toISOString();\n    }\n  }\n\n  /**\n   * Configure new TinySynq instance.\n   * \n   * @param opts - Configuration options\n   */\n  constructor(opts: TinySynqOptions) {\n    if (!opts.filePath && !opts.sqlite3) {\n      throw new Error('No DB filePath or connection provided');\n    }\n    const _synqTables: Record<string, SyncableTable> = {};\n    opts.tables.forEach(t => {\n      _synqTables[t.name] = t;\n    })\n    this._dbPath = opts.filePath || '';\n    this._db = opts.sqlite3 || undefined;\n    this._synqPrefix = opts.prefix?.trim().replace(/[^a-z0-9]+$/i, '');\n    this._synqTables = _synqTables;\n    this._synqBatchSize = opts.batchSize || this._synqBatchSize;\n    this._wal = opts.wal ?? false;\n    this.log = new Logger({\n      name: 'tinysync-node',\n      minLevel: LogLevel.Debug,\n      type: 'json',\n      maskValuesOfKeys: ['password', 'encryption_key'],\n      hideLogPositionForProduction: true,\n      ...(opts.logOptions || {})\n    });\n\n    if (!this.db) {\n      this._db = new DB(this.dbPath);\n      this.db.pragma('journal_mode = WAL');\n    }\n  }\n\n  /**\n   * better-sqlite3 instance (See {@link https://github.com/WiseLibs/better-sqlite3/blob/master/docs/api.md | BetterSqlite3})\n   */\n  get db() {\n    return this._db;\n  }\n\n  /**\n   * Path to DB file\n   * \n   * @example\n   * \n   * `./app.db` or `/tmp/app.db`\n   */\n  get dbPath() {\n    return this._dbPath;\n  }\n\n  /**\n   * Automatically generated ID for device's DB instance.\n   * \n   * @remarks\n   * \n   * This ID is used by the sync protocol to identify the database.\n   * One it is generated once during setup and does not change. The\n   * value is stored in the `_meta` table (`meta_name='device_id'`).\n   * __Do not edit this value; doing so would corrupt synchronisation__.\n   */\n  get deviceId() {\n    return this._deviceId;\n  }\n\n  /**\n   * Alias for {@link TinySynq.deviceId}.\n   */\n  get synqDbId() {\n    return this._deviceId;\n  }\n\n  /**\n   * The prefix used for TinySynq's tables.\n   * \n   * @defaultValue `tinysync`\n   */\n  get synqPrefix() {\n    return this._synqPrefix;\n  }\n\n  /**\n   * Object containing {@link SyncableTable}s, keyed by table name.\n   * \n   * @remarks\n   * \n   * A {@link SyncableTable} structure is never modified. TinySynq maintains \n   * its own tables and triggers for tracking and responding to changes.\n   * \n   * @returns Record\\<string, SyncableTable\\>\n   */\n  get synqTables() {\n    return this._synqTables;\n  }\n\n  /**\n   * Number of records to process in each batch when syncing changes. \n   */\n  get synqBatchSize() {\n    return this._synqBatchSize;\n  }\n\n  /**\n   * Enable or disable WAL mode.\n   * \n   * @defaultValue true\n   */\n  get wal() {\n    return this._wal;\n  }\n\n  /**\n   * Get a random 16-character ID generated by nanoid\n   * \n   * @returns string\n   */\n  getNewId() {\n    return nanoid(16);\n  }\n\n  /**\n   * Get the column used as identifier for the {@link SyncableTable}.\n   * \n   * @param params - Details of table for which to retrieve ID column.\n   * @returns Column name\n   */\n  getTableIdColumn(params: GetTableIdColumnParams) {\n    const {table_name} = params;\n    return this.synqTables![table_name]?.id as string;\n  }\n\n  /**\n   * If not already set, generates and sets deviceId.\n   */\n  setDeviceId() {\n    // Set the device ID\n    let existing: any;\n    try {\n      existing = this.runQuery<any[]>({\n        sql: `SELECT meta_value FROM ${this.synqPrefix}_meta WHERE meta_name = 'device_id'`\n      })[0];\n    }\n    catch(err) {\n      this.log.warn(`Couldn't retrieve device ID`);\n    }\n\n    log.warn('@device_id', existing);\n    if (!existing?.meta_value) {\n      const res = this.runQuery<any[]>({\n        sql: `INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value) VALUES (?,?) RETURNING *`,\n        values: ['device_id', nanoid(16)]\n      });\n      log.warn('@created record for device_id:', res);\n      existing = res[0];\n    }\n    this._deviceId = existing?.meta_value;\n  }\n\n  /**\n   * Run an operation against the DB\n   * \n   * @remarks\n   * This method does not return any records, only the result of the operation.\n   * \n   * @param params - The SQL query and optionally any values.\n   * @returns\n   */\n  run<T>(params: QueryParams): T {\n    const {sql, values} = params;\n    const quid = Math.ceil(Math.random() * 1000000);\n    this.log.debug('@run', quid, sql, values, '/');\n    try {\n      const result = this.db.prepare(sql).run(values || []);\n      this.log.debug({quid, result});\n      return result;\n    }\n    catch(err: any) {\n      this.log.error(quid, err);\n      return err;\n    }\n  }\n\n  /**\n   * Run multiple operations against the DB\n   * \n   * @remarks\n   * This method does not return any records.\n   * \n   * @param params - The SQL query and optionally an array of arrays or key/value pairs\n   * @returns Undefined or an error, if one occurred\n   */\n  runMany(params: {sql: string, values: any[]}) {\n    const {sql, values} = params;\n    const quid = Math.ceil(Math.random() * 1000000);\n    this.log.debug('@runMany', quid, sql, values, '/');\n    try {\n      const query = this.db.prepare(sql);\n      for (const v of values) {\n        query.run(v);\n      }\n      this.log.debug({quid, result: 'done'});\n    }\n    catch(err: any) {\n      this.log.error(quid, err);\n      return err;\n    }\n  }\n\n  /**\n   * Run an operation against the DB\n   * \n   * @param params - The SQL query and optionally any values\n   * @returns Array of records returned from the database\n   */\n  runQuery<T = any>(params: QueryParams): T {\n    const {sql, values} = params;\n    const quid = Math.ceil(Math.random() * 1000000);\n    this.log.debug('@runQuery', {quid, sql, values});\n    try {\n      const result = this.db.prepare(sql).all(values || []);\n      this.log.debug({quid, result});\n      return result;\n    }\n    catch(err: any) {\n      this.log.error(quid, err);\n      return err;\n    }\n  }\n\n  /**\n   * Returns the current device's unique TinySynq ID.\n   * \n   * @returns The device's assigned ID.\n   */\n  getDeviceId(): string {\n    if (this._deviceId) return this._deviceId;\n    const res = this.runQuery<any[]>({\n      sql:`\n        SELECT meta_value FROM ${this.synqPrefix}_meta\n        WHERE meta_name = 'device_id'`\n    });\n    return res[0].meta_value;\n  }\n\n  /**\n   * Returns an ISO8601 formatted date and time of the last successful local sync.\n   * \n   * @remarks\n   * \n   * A \"local sync\" is the process of sending local changes to the remote hub.\n   * \n   * @returns The time of the last sync.\n   */\n  getLastSync(): string {\n    const res = this.runQuery<any[]>({\n      sql:`\n        SELECT meta_value FROM ${this.synqPrefix}_meta\n        WHERE meta_name = 'last_local_sync'`\n    });\n    this.log.trace('@getLastSync', res[0]);\n    return res[0]?.meta_value;\n  }\n  \n  /**\n   * Returns matching {@link Change} objects since the last local sync.\n   * \n   * @remarks\n   * \n   * If `lastLocalSync` is empty, all changes are returned.\n   * \n   * @param params - Object containing retrieval parameters.\n   * @returns An array of {@link Change} objects.\n   */\n  getChanges(params?: {lastLocalSync?: string, columns?: string[]}): Change[] {\n    let lastLocalSync: string = params?.lastLocalSync || this.getLastSync();\n    let { columns = [] } = params || {};\n    this.log.debug('@getChanges', lastLocalSync);\n  \n    let where: string = '';\n    let columnSelection = columns\n      .map(c => c.replace(/[^*._a-z0-9]+/gi, ''))\n      .join(',') || '*';\n  \n    if (lastLocalSync) {\n      where = 'WHERE c.modified > ?'\n    }\n    const sql = `\n      SELECT ${columnSelection}\n      FROM ${this._synqPrefix}_changes c\n      INNER JOIN ${this._synqPrefix}_record_meta trm\n      ON trm.table_name = c.table_name\n      AND trm.row_id = c.row_id\n      ${where}\n      ORDER BY c.modified ASC\n    `;\n    console.log(sql)\n    const values = lastLocalSync ? [lastLocalSync] : [];\n    this.log.debug(sql, values);\n  \n    return this.runQuery<Change[]>({sql, values});\n  };\n\n  /**\n   * Returns {@link Change} objects since the last local sync.\n   * \n   * @remarks\n   * \n   * If `lastLocalSync` is empty, all changes are returned.\n   * \n   * @param params - Object containing retrieval parameters.\n   * @returns An array of {@link Change} objects.\n   */\n  getChangesSinceLastSync(params?: {columns?: string[]}): Change[] {\n    let lastLocalSync = this.getLastSync() || undefined;\n    return this.getChanges({...params, lastLocalSync});\n  };\n\n  /**\n   * Writes debug mode value (true) which disables recording \n   * of operations on syncable tables.\n   * \n   * @remarks\n   * \n   * The value set by this method is checked by dedicated triggers.\n   * If the value is `1`, the active trigger writes the data to the\n   * `*_dump` table. It's worth purging the table data once done \n   * with debugging.\n   * \n   * @returns Result of the operation.\n   */\n  enableDebug() {\n    return this.run({\n      sql: `\n      INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value)\n      VALUES ('debug_on', '1')\n      RETURNING *;`\n    });\n  }\n\n  /**\n   * Writes debug mode value (false) which disables recording \n   * of operations on syncable tables.\n   * \n   * @see {@link TinySynq.enableDebug} for more details.\n   * \n   * @returns Result of the operation.\n   */\n  disableDebug() {\n    return this.run({\n      sql: `\n      INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value)\n      VALUES ('debug_on', '0')\n      RETURNING *;`\n    });\n  }\n\n  /**\n   * Empties the `*_dump` table.\n   * \n   * @see {@link TinySynq.enableDebug} for more details.\n   */\n  clearDebugData() {\n    this.run({sql: `DELETE FROM ${this._synqPrefix}_dump`});\n    this.run({sql: `UPDATE SQLITE_SEQUENCE SET seq = 0 WHERE name = ${this._synqPrefix}_dump`});\n  }\n  \n  /**\n   * Writes value (true) which determines whether or not triggers on syncable\n   * tables are executed.\n   * \n   * @returns Result of operation.\n   */\n  private enableTriggers() {\n    return this.run({\n      sql: `\n      INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value)\n      VALUES ('triggers_on', '1');`\n    });\n  }\n\n  /**\n   * Writes value (true) which determines whether or not triggers on syncable\n   * tables are executed.\n   * \n   * @returns Result of operation.\n   */\n  private disableTriggers() {\n    return this.run({\n      sql: `\n      INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value)\n      VALUES ('triggers_on', '0');`\n    });\n  }\n\n  private beginTransaction(): string {\n    const savepoint = `SP${Date.now()}`;\n    const sql = `SAVEPOINT ${savepoint};`;\n    this.run({sql});\n    return savepoint;\n  }\n\n  private commitTransaction({savepoint}: {savepoint: string}) {\n    const sql = `RELEASE SAVEPOINT ${savepoint};`;\n    return this.run({sql});\n  }\n\n  private rollbackTransaction({savepoint}: {savepoint: string}) {\n    const sql = `ROLLBACK TRANSACTION TO SAVEPOINT ${savepoint};`;\n    return this.run({sql});\n  }\n\n  /**\n   * Retrieves a single record.\n   * \n   * @param params - Object containing table/row parameters. \n   * @returns \n   */\n  private getRecord<T>(params: TableNameRowParams): T|any {\n    const {table_name, row_id} = params;\n    const idCol = this.getTableIdColumn({table_name: table_name});\n    const sql = `SELECT * FROM ${table_name} WHERE ${idCol} = ?`;\n    const res = this.runQuery({sql, values: [row_id]});\n    this.log.debug('@getRecord', res);\n    return res[0];\n  }\n\n  /**\n   * Retrieves a single record by it's ID.\n   * \n   * @remarks\n   * \n   * The column used to identify the record is according to the {@link SyncableTable}\n   * that was provided in {@link TinySynqOptionsBase.tables} at instantiation.\n   * \n   * @param params - Object containing table/row parameters. \n   * @returns \n   */\n  getById<T>(params: TableNameRowParams): T | any {\n    const{table_name, row_id} = params;\n    return this.getRecord({table_name, row_id});\n  }\n\n  insertRecordMeta({change, vclock}: any) {\n    //this.log.warn('<<< @insertRecordMeta >>>', {change, vclock});\n    const { table_name, row_id } = change;\n    const mod = vclock[this._deviceId!] || 0;\n    const values = {\n      table_name,\n      row_id,\n      mod,\n      vclock: JSON.stringify(vclock)\n    };\n    return this.runQuery({\n      sql: `\n      INSERT INTO ${this._synqPrefix}_record_meta (table_name, row_id, mod, vclock)\n      VALUES (:table_name, :row_id, :mod, :vclock)\n      ON CONFLICT DO UPDATE SET mod = :mod, vclock = :vclock\n      RETURNING *\n      `,\n      values,\n    });\n  }\n\n  /**\n   * Get associated meta data (including `vclock`) for record.\n   * \n   * @param params - Object containing table/row parameters.\n   * \n   * @returns Object containing row data from `*_record_meta`.\n   */\n  getRecordMeta(params: {table_name: string, row_id: string}) {\n    const {table_name, row_id} = params;\n    const sql = `\n    SELECT *\n    FROM ${this.synqPrefix}_record_meta\n    WHERE table_name = :table_name\n    AND row_id = :row_id`;\n    const res = this.db.prepare(sql).get({table_name, row_id});\n    return res;\n  }\n\n  /**\n   * Returns changes that couldn't be applied yet because they\n   * were received out of sequence.\n   * \n   * @returns Array of pending changes.\n   */\n  getPending() {\n    const sql = `\n    SELECT *\n    FROM ${this._synqPrefix}_pending\n    ORDER BY id ASC\n    `;\n    const res = this.runQuery({sql});\n    return res;\n  }\n\n  /**\n   * Creates new pending record to be applied later.\n   * \n   * @param opts - Options for processing out-of-order change\n   * @returns Newly created pending record\n   */\n  private processOutOfOrderChange({change}: {change: Change}) {\n    const {id, ...data} = change;\n    const sql = this.createInsertFromSystemObject({\n      data,\n      table_name: `${this._synqPrefix}_pending`,\n    });\n    this.log.trace('@processOutOfOrderChange\\n', sql, change);\n    const values: any = { ...data};\n    values.vclock = JSON.stringify(data.vclock);\n    const res = this.runQuery({sql, values});\n    this.log.trace('@processOutOfOrderChange\\n', {res});\n    return res;\n  }\n\n  /**\n   * Determines whether to treat conflicted change as valid or invalid.\n   * \n   * @param opts - Options for processing concurrent change\n   * @returns boolean \n   */\n  private processConflictedChange<T>({ record, change }: {record: T|any, change: Change}): boolean {\n    // INSERT won't have a local record so accept the incoming change\n    if (change.operation === TinySynqOperation.INSERT) return true;\n\n    const localMeta = this.getRecordMeta({...change});\n    this.log.trace('<<<@ processConflictedChange LLW @>>>', change.id, change.table_name, change.row_id, {record, localMeta, change});\n    if (change.modified > localMeta.modified) {\n      this.log.trace('<!> INTEGRATING REMOTE', change.id, change.table_name, change.row_id);\n      // Update local with the incoming changes\n      return true;\n    }\n    else {\n      this.log.warn('<!> KEEPING LOCAL', change.id, change.table_name, change.row_id);\n      // Keep the local change, but record receipt of the record.\n      return false;\n    }\n  }\n\n  /**\n   * Checks for and handles issues with incoming change to be applied.\n   * \n   * @returns Result of pre-processing.\n   */\n  private preProcessChange(\n    {change, restore}: PreProcessChangeOptions\n  ): PreProcessChangeResult {\n    let defaultReason = 'unknown';\n    let valid = false;\n    let reason = defaultReason;\n    const localId = this.deviceId!;\n    const { table_name, row_id, vclock: remote = {} } = change;\n    const record = this.getRecord({table_name, row_id});\n    const meta = this.getRecordMeta({table_name, row_id});\n    const local = meta?.vclock ? JSON.parse(meta.vclock) : {};\n    const localTime = meta?.modified;\n    const remoteTime = change.modified;\n\n    let latest: VClock = {};\n    const localV = new VCompare({ local, remote, localId, localTime, remoteTime });\n    let displaced = false;\n    let conflicted = false;\n    let stale = false;\n\n    // If we don't have the record, treat it as new\n    if (!restore && !record && change.operation !== SYNQ_INSERT) {\n      reason = 'update before insert';\n      this.processOutOfOrderChange({change});\n    }\n    else if (restore || !record || !local || !local[localId]) {\n      latest = change.vclock;\n    }\n    \n    if (restore) {\n      valid = true;\n      reason = 'restoration';\n      latest = localV.merge();\n      return { valid, reason, vclock: latest, checks: { stale, displaced, conflicted } };\n    }\n    else if (displaced = localV.isOutOfOrder()) {  \n      reason = 'received out of order';\n      this.processOutOfOrderChange({change});\n    }\n    else if (conflicted = localV.isConflicted()) {\n      valid = this.processConflictedChange({record, change});\n      if (!valid) {\n        reason = 'concurrent writes'; \n      }\n      else {\n        latest = localV.merge();\n      }\n    }\n    else if (stale = localV.isOutDated()) {\n      reason = 'stale';\n    }\n    else if (reason === defaultReason) {\n      valid = true;\n      reason = '';\n      latest = localV.merge();\n    }\n\n    this.log.debug({table_name, row_id, conflicted, displaced, stale});\n\n    return { valid, reason, vclock: latest, checks: { stale, displaced, conflicted } };\n  }\n\n  /**\n   * Creates an insert query based on the syncable table name and data provided.\n   * \n   * @remarks\n   * \n   * This method is specifically for tables that have been registerd as syncable\n   * by passing them in as a {@link SyncableTable} at instantiation.\n   * \n   * @see {@link SyncableTable} for more information.\n   * \n   * @param param0 - Parameters from which to create the query.\n   * @returns A SQL query string.\n   */\n  createInsertFromObject({data, table_name: table}: { data: Record<string, any>, table_name: string }) {\n    const columnsToInsert = Object.keys(data).join(',');\n    const editable = this._synqTables![table].editable || [];\n    const updates = Object.keys(data)\n      .filter(key => editable.includes(key))\n      .map(k => `${k} = :${k}`)\n      .join(',');\n    \n    if (!updates) throw new Error('No changes available');\n    const insertPlaceholders = Object.keys(data).map(k => `:${k}`).join(',');\n    const insertSql = `\n      INSERT INTO ${table} (${columnsToInsert})\n      VALUES (${insertPlaceholders})\n      ON CONFLICT DO UPDATE SET ${updates}\n      RETURNING *;`;\n\n    return insertSql;\n  }\n\n  /**\n   * Creates an insert query based on the system table name and data provided.\n   *  \n   * @param param0 - Parameters from which to create the query.\n   * \n   * @returns A SQL query string. \n   */\n  private createInsertFromSystemObject({data, table_name: table}: { data: Record<string, any>, table_name: string }) {\n    this.log.silly('@createInsert...', {data});\n    const columnsToInsert = Object.keys(data).join(',');\n    const updates = Object.keys(data)\n      .map(k => `${k} = :${k}`)\n      .join(',');\n    \n    if (!updates) throw new Error('No changes availble');\n    const insertPlaceholders = Object.keys(data).map(k => `:${k}`).join(',');\n    const insertSql = `\n      INSERT INTO ${table} (${columnsToInsert})\n      VALUES (${insertPlaceholders})\n      ON CONFLICT DO UPDATE SET ${updates}\n      RETURNING *;`;\n\n    return insertSql;\n  }\n\n  private updateLastSync({change}: {change: Change}) {\n    this.run({\n      sql: `INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value) VALUES(:name, STRFTIME('%Y-%m-%d %H:%M:%f','NOW'))`,\n      values: { name: 'last_local_sync'},\n    });\n    this.run({\n      sql: `INSERT OR REPLACE INTO ${this.synqPrefix}_meta (meta_name, meta_value) VALUES(:name, :value)`,\n      values: { name: 'last_sync', value: change.id }\n    });\n  }\n\n  private async applyChange({\n    change,\n    restore,\n    savepoint\n  }: ApplyChangeParams) {\n    try {\n      // Check that the changes can actually be applied\n      const changeStatus = this.preProcessChange({change, restore});\n      if (!changeStatus.valid) {\n        this.log.warn(changeStatus);\n        this.updateLastSync({change});\n        return;\n      }\n\n      const table = this.synqTables![change.table_name];\n      let recordData: any;\n      if (change.data) {\n        try {\n          recordData = JSON.parse(change.data);\n        }\n        catch(err) {\n          this.log.debug(change);\n          throw new Error('Invalid data for insert or update');\n        }\n      }\n      else {\n        // There's no data so bail\n        throw new Error(`Cannot perform update with empty data:\\n${JSON.stringify(change, null, 2)}`);\n      }\n \n      if (!table) throw new Error(`Unable to find table ${change.table_name}`);\n      this.log.silly('@applyChange', {change, table, changeStatus});\n      switch(change.operation) {\n        case 'INSERT':\n        case 'UPDATE':\n          const insertSql = this.createInsertFromObject({\n            data: recordData,\n            table_name: change.table_name\n          });\n          await this.run({sql: insertSql, values: recordData});\n          break;\n        case 'DELETE':\n          const sql = `DELETE FROM ${change.table_name} WHERE ${table.id} = ?`;\n          this.log.warn('>>> DELETE SQL <<<', sql, change.row_id);\n          await this.run({sql, values: [change.row_id]});\n          break;\n      }\n\n      this.updateLastSync({change});\n\n      // Insert merged VClock data\n      const updatedRecordMeta = this.insertRecordMeta({change, vclock: changeStatus.vclock});\n      this.log.silly({updatedRecordMeta});\n    }\n    catch (error) {\n      await this.rollbackTransaction({savepoint})\n      this.log.error(`Error applying change: ${error}. Rolled back.`);\n      throw error; // Throw the error to trigger rollback\n    }\n  }\n  \n  applyChangesToLocalDB({ changes, restore = false }: { changes: Change[], restore?: boolean }) {\n    this.disableTriggers();\n    // Split changes into batches\n    for (let i = 0; i < changes.length; i += this.synqBatchSize) {\n      const batch = changes.slice(i, i + this.synqBatchSize);\n  \n      // Create savepoint and apply each batch within a transaction\n      const savepoint = this.beginTransaction();\n      try {\n        for (const change of batch) {\n          this.applyChange({change, restore, savepoint})\n        }\n\n        // Commit the changes for this batch\n        this.commitTransaction({savepoint});\n\n      } catch (error) {\n        this.rollbackTransaction({savepoint})\n        this.log.error(`Transaction failed, changes rolled back: ${error}`);\n        // Handle transaction failure (e.g., log, retry logic, notification)\n      }\n    }\n    this.enableTriggers();\n    this.log.silly(`Applied ${changes.length} change(s)`);\n  };\n\n  tablesReady() {\n    this.enableTriggers();\n  }\n}","export const SYNQLITE_PREFIX = 'synql';\nexport const SYNQLITE_BATCH_SIZE = 20;\nexport const SYNQLITE_NANOID_SIZE = 16;\n\nexport const SYNQ_INSERT = 'INSERT';\nexport const SYNQ_UPDATE = 'UPDATE';\nexport const SYNQ_DELETE = 'DELETE';","import { Logger } from \"tslog\";\nimport { TinySynq } from \"./tinysynq.class.js\";\nimport { TinySynqOptions, SyncableTable } from \"./types.js\";\n\n/**\n * Returns a configured instance of TinySynq\n * \n * @param config - Configuration object \n * @returns TinySynq instance\n * \n * @public\n */\nconst setupDatabase = (config: TinySynqOptions) => {\n  const {\n    tables,\n    preInit,\n    postInit,\n    logOptions,\n    debug,\n  } = config;\n\n  if (!tables?.length) throw new Error('Syncable table data required');\n\n  const log = new Logger({ name: 'tinysync-setup', ...logOptions});\n  const db = new TinySynq(config);\n\n  const getRecordMetaInsertQuery = ({table, remove = false}: {table: SyncableTable, remove?: boolean}) => {\n    /* \n    db.is kind of insane, but it works. A rundown of what's happening:\n    - We're creating a trigger after a deletion (the easy part)\n    - Aside from recording the changes, we also need to add record-specific metadata:\n      - table name and row identifier,\n      - the number of times the record has been touched (including creation)\n      - the map of all changes across all devices — a Vector Clock (JSON format)\n    - Getting the vector clock is tricky, partly because of SQLite limitations\n      (no variables, control structures), and partly because it's possible that\n      no meta exists for the record.\n    - To work around db.we do a select to get the meta, but perform a union with\n      another select that just selects insert values.\n    - Included in both selects is\n      a 'peg' which we use to sort the UNIONed rows to ensure that if a valid row\n      exists, it's the first row returned.\n    - Now we select from db.union and limit to 1 result. If a record exists\n      then we get that record. If not, we get the values ready for insertion.\n    - Finally, if there's a conflict on PRIMAY KEY or UNIQUE contraints, we update\n      only the columns configured as editable.\n    */\n    const version = remove ? 'OLD' : 'NEW';\n    const sql = `\n    INSERT INTO ${db.synqPrefix}_record_meta (table_name, row_id, mod, vclock)\n    SELECT table_name, row_id, mod, vclock\n    FROM (\n      SELECT\n        1 as peg,\n        '${table.name}' as table_name,\n        ${version}.${table.id} as row_id, \n        IFNULL(json_extract(vclock,'$.${db.deviceId}'), 0) + 1 as mod, \n        json_set(IFNULL(json_extract(vclock, '$'),'{}'), '$.${db.deviceId}', IFNULL(json_extract(vclock,'$.${db.deviceId}'), 0) + 1) as vclock\n      FROM ${db.synqPrefix}_record_meta\n      WHERE table_name = '${table.name}'\n      AND row_id = ${version}.${table.id}\n      UNION\n      SELECT 0 as peg, '${table.name}' as table_name, ${version}.${table.id} as row_id, 1, json_object('${db.deviceId}', 1) as vclock\n    )\n    ORDER BY peg DESC\n    LIMIT 1\n    ON CONFLICT DO UPDATE SET\n      mod = json_extract(excluded.vclock,'$.${db.deviceId}'),\n      vclock = json_extract(excluded.vclock,'$')\n    ;`;\n    log.silly(sql);\n    return sql;\n  }\n\n  const setupTriggersForTable = ({ table }: { table: SyncableTable }) => {\n    log.debug('Setting up triggers for', table.name);\n\n    // Template for inserting the new value as JSON in the `*_changes` table.\n    const jsonObject = (db.runQuery<any>({\n      sql:`\n      SELECT 'json_object(' || GROUP_CONCAT('''' || name || ''', NEW.' || name, ',') || ')' AS jo\n      FROM pragma_table_info('${table.name}');`\n    }))[0];\n    log.silly('@jsonObject', JSON.stringify(jsonObject, null, 2));\n\n    /**\n     * These triggers run for changes originating locally. They are disabled\n     * when remote changes are being applied (`triggers_on` in `*_meta` table).\n     */\n\n    // Ensure triggers are up to date\n    db.run({sql: `DROP TRIGGER IF EXISTS ${db.synqPrefix}_after_insert_${table.name}`});\n    db.run({sql: `DROP TRIGGER IF EXISTS ${db.synqPrefix}_after_update_${table.name}`});\n    db.run({sql: `DROP TRIGGER IF EXISTS ${db.synqPrefix}_after_delete_${table.name}`});\n\n    const sql = `\n      CREATE TRIGGER IF NOT EXISTS ${db.synqPrefix}_after_insert_${table.name}\n      AFTER INSERT ON ${table.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${db.synqPrefix}_meta WHERE meta_name = 'triggers_on')='1'\n      BEGIN\n        INSERT INTO ${db.synqPrefix}_changes (table_name, row_id, operation, data)\n        VALUES ('${table.name}', NEW.${table.id}, 'INSERT', ${jsonObject.jo});\n\n        ${getRecordMetaInsertQuery({table})}\n      END;`\n    db.run({sql});\n\n    db.run({\n      sql:`\n      CREATE TRIGGER IF NOT EXISTS ${db.synqPrefix}_after_update_${table.name}\n      AFTER UPDATE ON ${table.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${db.synqPrefix}_meta WHERE meta_name = 'triggers_on')='1'\n      BEGIN\n        INSERT INTO ${db.synqPrefix}_changes (table_name, row_id, operation, data)\n        VALUES ('${table.name}', NEW.${table.id}, 'UPDATE', ${jsonObject.jo});\n\n        ${getRecordMetaInsertQuery({table})}\n      END;`\n    });\n\n    db.run({\n      sql:`\n      CREATE TRIGGER IF NOT EXISTS ${db.synqPrefix}_after_delete_${table.name}\n      AFTER DELETE ON ${table.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${db.synqPrefix}_meta WHERE meta_name = 'triggers_on')='1'\n      BEGIN\n        INSERT INTO ${db.synqPrefix}_changes (table_name, row_id, operation) VALUES ('${table.name}', OLD.${table.id}, 'DELETE');\n        \n        ${getRecordMetaInsertQuery({table, remove: true})}\n      END;`\n    });\n\n    /**\n     * All the triggers below will only be executed if `meta_name=\"debug_on\"`\n     * has the `meta_value=1` in the *_meta table, regardless of `triggers_on`.\n     */\n\n    // Remove previous versions\n    db.run({sql: `DROP TRIGGER IF EXISTS ${db.synqPrefix}_dump_after_insert_${table.name}`});\n    db.run({sql: `DROP TRIGGER IF EXISTS ${db.synqPrefix}_dump_after_update_${table.name}`});\n    db.run({sql: `DROP TRIGGER IF EXISTS ${db.synqPrefix}_dump_after_delete_${table.name}`});\n    db.run({sql: `DROP TRIGGER IF EXISTS ${db.synqPrefix}_dump_before_insert_record_meta`});\n    db.run({sql: `DROP TRIGGER IF EXISTS ${db.synqPrefix}_dump_after_insert_record_meta`});\n    db.run({sql: `DROP TRIGGER IF EXISTS ${db.synqPrefix}_dump_after_update_record_meta`});\n\n    /**\n     * @Debugging Do not remove\n     * These triggers allow a rudimentary tracing of DB actions on the synced tables.\n     */\n    db.run({\n      sql:`\n      CREATE TRIGGER IF NOT EXISTS ${db.synqPrefix}_dump_after_insert_${table.name}\n      AFTER INSERT ON ${table.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${db.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${db.synqPrefix}_dump (table_name, operation, data)\n        VALUES ('${table.name}', 'INSERT', ${jsonObject.jo});\n      END;`\n    });\n\n    db.run({\n      sql:`\n      CREATE TRIGGER IF NOT EXISTS ${db.synqPrefix}_dump_after_update_${table.name}\n      AFTER UPDATE ON ${table.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${db.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${db.synqPrefix}_dump (table_name, operation, data) VALUES ('${table.name}', 'UPDATE', ${jsonObject.jo});\n      END;`\n    });\n\n    const oldJsonObject = jsonObject.jo.replace(/NEW/g, 'OLD');\n    \n    db.run({\n      sql:`\n      CREATE TRIGGER IF NOT EXISTS ${db.synqPrefix}_dump_after_delete_${table.name}\n      AFTER DELETE ON ${table.name}\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${db.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${db.synqPrefix}_dump (table_name, operation, data) VALUES ('${table.name}', 'DELETE', ${oldJsonObject});\n      END;`\n    });\n\n    /**\n     * @Debugging Do not remove\n     * These triggers allow comparison record meta before and after insert.\n     */\n\n    db.run({\n      sql:`\n      CREATE TRIGGER IF NOT EXISTS ${db.synqPrefix}_dump_before_insert_record_meta\n      BEFORE INSERT ON ${db.synqPrefix}_record_meta\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${db.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${db.synqPrefix}_dump (table_name, operation, data)\n        VALUES (NEW.table_name, 'BEFORE_INSERT', json_object('table_name', NEW.table_name, 'row_id', NEW.row_id, 'mod', NEW.mod, 'vclock', NEW.vclock));\n      END;`\n    });\n\n    db.run({\n      sql:`\n      CREATE TRIGGER IF NOT EXISTS ${db.synqPrefix}_dump_after_insert_record_meta\n      AFTER INSERT ON ${db.synqPrefix}_record_meta\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${db.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${db.synqPrefix}_dump (table_name, operation, data)\n        VALUES ('${table.name}', 'AFTER_INSERT', json_object('table_name', NEW.table_name, 'row_id', NEW.row_id, 'mod', NEW.mod, 'vclock', NEW.vclock));\n      END;`\n    });\n\n    db.run({\n      sql:`\n      CREATE TRIGGER IF NOT EXISTS ${db.synqPrefix}_dump_after_update_record_meta\n      AFTER UPDATE ON ${db.synqPrefix}_record_meta\n      FOR EACH ROW\n      WHEN (SELECT meta_value FROM ${db.synqPrefix}_meta WHERE meta_name = 'debug_on')='1'\n      BEGIN\n        INSERT INTO ${db.synqPrefix}_dump (table_name, operation, data)\n        VALUES ('${table.name}', 'AFTER_UPDATE', json_object('table_name', NEW.table_name, 'row_id', NEW.row_id, 'mod', NEW.mod, 'vclock', NEW.vclock));\n      END;`\n    });\n\n    /* END OF DEBUG TRIGGERS */\n  }\n\n  // Create a change-tracking table and index\n  db.run({\n    sql:`\n    CREATE TABLE IF NOT EXISTS ${db.synqPrefix}_changes (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      table_name TEXT NOT NULL,\n      row_id TEXT NOT NULL,\n      data BLOB,\n      operation TEXT NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'\n      modified TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%d %H:%M:%f','NOW'))\n    );`\n  });\n  \n  db.run({\n    sql:`CREATE INDEX IF NOT EXISTS ${db.synqPrefix}_change_modified_idx ON ${db.synqPrefix}_changes(modified)`\n  });\n\n  // Change *_pending is essentially a clone of *_changes used to hold items that\n  // cannot be applied yet because intermediate/preceding changes haven't been received.\n  db.run({\n    sql:`\n    CREATE TABLE IF NOT EXISTS ${db.synqPrefix}_pending (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      table_name TEXT NOT NULL,\n      row_id TEXT NOT NULL,\n      data BLOB,\n      operation TEXT NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE',\n      vclock BLOB NOT NULL,\n      modified TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%d %H:%M:%f','NOW'))\n    );`\n  });\n  \n  db.run({\n    sql:`CREATE INDEX IF NOT EXISTS ${db.synqPrefix}_pending_table_row_idx ON ${db.synqPrefix}_pending(table_name, row_id)`\n  });\n\n  // Create a notice table\n  db.run({\n    sql:`\n    CREATE TABLE IF NOT EXISTS ${db.synqPrefix}_notice (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      table_name TEXT NOT NULL,\n      row_id TEXT NOT NULL,\n      conflict BLOB,\n      message TEXT NOT NULL,\n      created TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%dT%H:%M:%f','NOW'))\n    );`\n  }); \n\n  // Create record meta table and index\n  db.run({\n    sql:`\n    CREATE TABLE IF NOT EXISTS ${db.synqPrefix}_record_meta (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      table_name TEXT NOT NULL,\n      row_id TEXT NOT NULL,\n      mod INTEGER,\n      vclock BLOB,\n      modified TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%dT%H:%M:%f','NOW'))\n    );`\n  });\n\n  db.run({\n    sql:`CREATE UNIQUE INDEX IF NOT EXISTS ${db.synqPrefix}_record_meta_idx ON ${db.synqPrefix}_record_meta(table_name, row_id)`\n  });\n\n  // Create meta table\n  db.run({\n    sql:`\n    CREATE TABLE IF NOT EXISTS ${db.synqPrefix}_meta (\n      meta_name TEXT NOT NULL PRIMARY KEY,\n      meta_value TEXT NOT NULL\n    );\n  `});\n\n  db.run({\n    sql: `\n    CREATE TABLE IF NOT EXISTS ${db.synqPrefix}_dump (\n      created TIMESTAMP DATETIME DEFAULT(STRFTIME('%Y-%m-%d %H:%M:%f','NOW')), \n      table_name TEXT NOT NULL,\n      operation TEXT,\n      data BLOB\n    );\n  `});\n\n  db.run({\n    sql: `CREATE INDEX IF NOT EXISTS ${db.synqPrefix}_meta_name_idx ON ${db.synqPrefix}_meta(meta_name)`\n  });\n  \n  // Enable debug mode\n  if (debug) db.enableDebug();\n\n  // Set the device ID\n  db.setDeviceId();\n\n  // Run pre-initialisation queries\n  if (preInit?.length) {\n    for (const preInitQuery of preInit) {\n      log.debug(`\\n@@@ preInit\\n${preInitQuery}\\n@@@`)\n      db.run({\n        sql: preInitQuery\n      });\n    }\n  }\n\n  log.debug(`@${db.synqPrefix}_meta`, db.runQuery({sql:`SELECT * FROM pragma_table_info('${db.synqPrefix}_meta')`}));\n  log.debug(`@SIMPLE_SELECT`, db.runQuery({sql:`SELECT '@@@ that was easy @@@'`}));\n\n  for (const table of tables) {\n    // Check table exists\n    const exists = db.runQuery<Record<string, any>>({\n      sql: `SELECT * FROM pragma_table_info('${table.name}')`\n    });\n    log.debug('@exists?', table.name, exists);\n    if (!exists?.length) throw new Error(`${table.name} doesn't exist`);\n    \n    log.debug('Setting up', table.name, table.id);\n\n    setupTriggersForTable({ table });\n    db.tablesReady();\n  }\n\n  if (postInit?.length) {\n    for (const postInitQuery of postInit) {\n      log.debug(`@@@\\npostInit\\n${postInitQuery}\\n@@@`)\n      db.run({\n        sql: postInitQuery\n      });\n    }\n  }\n\n  return db;\n};\n\nexport default setupDatabase;"],"names":["TinySynqOperation","LogLevel","VCompare","_ref","local","remote","localId","localTime","remoteTime","this","isGreater","isLess","isWrongOrder","JSON","parse","_proto","prototype","setRemote","_ref2","isConflicted","data","_this","Object","keys","_extends","forEach","k","localCount","remoteCount","isOutDated","_this$localTime","Date","toISOString","Error","isOutOfOrder","filter","i","length","_local$k","_remote$k","drift","Math","abs","merge","_step","merged","_iterator","_createForOfIteratorHelperLoose","Set","concat","done","p","value","max","undefined","_excluded","_settle","pact","state","o","bind","s","v","then","observer","_Pact","onFulfilled","onRejected","result","callback","log","Logger","name","minLevel","Info","strtimeAsISO8601","TinySynq","opts","_opts$prefix","_opts$wal","_db","_dbPath","_deviceId","_synqPrefix","_synqTables","_synqBatchSize","_wal","utils","nowAsISO8601","utcNowAsISO8601","toUTCString","filePath","sqlite3","tables","t","prefix","trim","replace","batchSize","wal","Debug","type","maskValuesOfKeys","hideLogPositionForProduction","logOptions","db","DB","dbPath","pragma","getNewId","nanoid","getTableIdColumn","params","_this$synqTables$tabl","synqTables","table_name","id","setDeviceId","_existing","_existing2","existing","runQuery","sql","synqPrefix","err","warn","meta_value","res","values","run","quid","ceil","random","debug","prepare","error","runMany","query","all","getDeviceId","getLastSync","_res$","trace","getChanges","lastLocalSync","_ref$columns","columns","where","columnSelection","map","c","join","console","getChangesSinceLastSync","enableDebug","disableDebug","clearDebugData","enableTriggers","disableTriggers","beginTransaction","savepoint","now","commitTransaction","rollbackTransaction","_ref3","getRecord","row_id","idCol","getById","insertRecordMeta","_ref4","change","vclock","mod","stringify","getRecordMeta","get","getPending","processOutOfOrderChange","_ref5","_objectWithoutPropertiesLoose","createInsertFromSystemObject","processConflictedChange","_ref6","record","operation","INSERT","localMeta","modified","preProcessChange","_ref7","restore","defaultReason","valid","reason","deviceId","_change$vclock","meta","latest","localV","displaced","conflicted","stale","checks","createInsertFromObject","_ref8","table","columnsToInsert","editable","updates","key","includes","insertPlaceholders","_ref9","silly","updateLastSync","_ref10","applyChange","_ref11","Promise","resolve","body","recover","_temp2","updatedRecordMeta","changeStatus","recordData","_temp","discriminant","cases","dispatchIndex","test","testValue","outer","awaitBody","fallthroughCheck","_resumeAfterBody","_resumeAfterTest","reject","_switch","insertSql","_interrupt","e","_catch","applyChangesToLocalDB","_ref12","changes","_ref12$restore","synqBatchSize","batch","slice","_step2","_iterator2","tablesReady","config","preInit","postInit","getRecordMetaInsertQuery","_ref$remove","remove","version","setupTriggersForTable","jsonObject","jo","oldJsonObject","preInitQuery","exists","_step3","_iterator3","postInitQuery"],"mappings":"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"}